<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Degrees of Pynchon</title>
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="style.css" type="text/css">
</head>
<body>
  <h1>Degrees of Pynchon</h1>
  <h2>"Thomas Pynchon loved this graph, almost as much as he loves cameras!"</h2>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="writers.js"></script>
<script>
  // var data = writers['Thomas Pynchon'];
  // var nodes = data.nodes;
  // var links = data.links;
  var width = 1200,
      height = 550,
      margin = { top: 30, right: 40, bottom: 50, left: 50 };

  var colors = d3.scale.category20();

  var svg = d3.select('body').append('svg')
    .attr('width', width + margin.right + margin.left)
    .attr('height', height + margin.top + margin.bottom);


  var fadeGraph = function() {
    svg.selectAll('circle').attr('opacity', 0.08);
    svg.selectAll('text').attr('opacity', 0.08);
    svg.selectAll('path').attr('opacity', 0.08);
  };

  var unfadeGraph = function() {
    svg.selectAll('circle').attr('opacity', 1);
    svg.selectAll('text').attr('opacity', 1);
    svg.selectAll('path').attr('opacity', 1);
  };

  var createGraph = function(data, g, centerColor) {
    var nodes = data.nodes;
    var links = data.links;

    if (nodes.length > 0) {
      var xScale = d3.scale.linear()
        .domain([0, nodes.length])
        .range([0, height]);

      var centerPos = width / 2;

      // Draw nodes
      nodes.forEach(function(d, i) {
        if (d.group === 0) {
          d.x = centerPos;
          d.cx = centerPos;
        } else if (d.group === 1) {
          d.x = -Math.round(xScale(i)) + (centerPos);
          d.cx = d.x + (i * 8);
        } else if (d.group === 2) {      
          d.x = Math.round(xScale(i)) + (centerPos);
          d.cx = d.x + (i * 8);
        }
        d.y = 300;
      });

      g.selectAll('circle')
        .data(nodes)
        .enter()
        .append('circle')
          .attr('fill', function(d, i) {
            if (d.group === 0) {
              return centerColor;
            } else {
              return colors(i); 
            }
          })
          .attr('cx', function(d, i) { return d.cx; })
          .attr('cy', function(d, i) { return d.y; })
          .attr('r', 4);

      g.selectAll('text')
        .data(nodes)
        .enter()
        .append('text')
          .text(function(d, i) {
            if (d.group !== 0) {
              return d.nodeName;
            }
          })
          .attr('class', 'writer')
          .attr('style', function(d, i) {
            return "fill: " + colors(i) + ";";
          })
          .attr('x', function(d, i) { return d.cx; })
          .attr('y', function(d, i) { 
            if (d.group === 1) {
              return d.y + 20;
            } else {
              return d.y - 20; 
            }
          })
          .attr('transform', function(d, i) {
            if (d.group === 1) {
              return 'rotate(90 ' + (d.cx) + ',' + (d.y + 20) + ')'
            } else {
              return 'rotate(-90 ' + (d.cx) + ',' + (d.y - 20) + ')'
            }
          });

      // Draw arcs
      links.forEach(function(d, i) {
        if (nodes[d.source].group === 1) {
          d.x = (nodes[d.source].x + centerPos) * 1.2;
        } else if (nodes[d.source].group === 2) {
          d.x = (nodes[d.source].x - centerPos) * 1.2;
        }
        d.y = nodes[d.source].y - 300;
        d.r = Math.sqrt(d.x * d.x + d.y * d.y);
      });

      g.selectAll('path')
        .data(links)
        .enter()
        .append('path')
          .style('fill', 'transparent')
          .style('stroke', function(d, i) {
            return colors(i);
          })
          .attr('d', function(d) {
            return 'M ' + nodes[d.source].cx + ', ' + 100 + ' A ' + d.r + ' ' + d.r + ' 0 0 1' + nodes[d.target].cx + ', ' + 100;
            // return 'M ' + nodes[d.source].cx + ', ' + 100 + ' A ' + d.r + ' ' + d.r + ' 0 0 1' + ((width / 2) - centerNode.cx) + ', ' + 100;
            //return 'M ' + nodes[d.source].cx + ', ' + 100 + ' A ' + d.r + ' ' + d.r + ' 0 0 1' + centerNode.cx + ', ' + 100;

          })
          .attr('transform', 'translate(0, 200)'); 

      g.on('mouseleave', function(d) {
        g.remove();
        unfadeGraph();
      });
    }
  }

  var redraw = function(obj) {
    var data = writers[obj.nodeName];

    if (data !== undefined) {
      fadeGraph();
      var g = svg.append('g').attr('width', width);
      var centerNode;

      // var leftHalf = {'nodes': [], 'links': []};
      // var rightHalf = {'nodes': [], 'links': []};
      // // var leftStartingPoint;
      // // var rightStartingPoint;

      // var nodes = data.nodes;
      // var links = data.links;

      // for (var i = 0; i < nodes.length; i++) {
      //   if (nodes[i].group === 1) {
      //     // if (leftStartingPoint === undefined) {
      //     //   leftStartingPoint = i;
      //     // }
      //     leftHalf.nodes.push(nodes[i]);
      //     leftHalf.links.push(links[i]);
      //   } else if (nodes[i].group === 2) {
      //     // if (rightStartingPoint === undefined) {
      //     //   rightStartingPoint = i;
      //     // }
      //     rightHalf.nodes.push(nodes[i]);
      //     rightHalf.links.push(links[i]);
      //   }
      // }

      var centerColor;

      g.selectAll('circle')
        .data([obj])
        .enter()
        .append('circle')
          .attr('fill', function(d) {
            centerColor = d.color;
            return centerColor;
          })
          .attr('cx', function(d) { return d.cx; })
          .attr('cy', function(d) { return d.y; })
          .attr('r', 4)
        .transition()
        .delay(1500)
        .attr('transform', function(d) {
          return 'translate(' + (width / 2 - d.cx) + ', 0)';
        });

      g.selectAll('text')
        .data([obj])
        .enter()
        .append('text')
          .text(function(d, i) {
            return d.nodeName;
          })
          .attr('style', function(d, i) {
            return "fill: " + d.color + ";";
          })
          .attr('x', function(d, i) { return d.cx; })
          .attr('y', function(d, i) { 
            if (d.group === 1) {
              return d.y + 20;
            } else {
              return d.y - 20; 
            }
          })
          .attr('transform', function(d) {
            if (d.group === 1) {
              return 'rotate(270 ' + (d.cx) + ',' + (d.y + 20) + ')'
            } else {
              return 'rotate(-270 ' + (d.cx) + ',' + (d.y - 20) + ')'
            }
          })
          .transition()
          .delay(1500)
          .attr('transform', function(d) {
            return 'translate(' + (width / 2 - d.cx) + ', 0)';
          });

      setTimeout(function() {
        createGraph(data, g, centerColor);
      }, 2500);
    }
  };

  var draw = function() {
    var data = writers['Thomas Pynchon'];
    var nodes = data.nodes;
    var links = data.links;
    var g = svg.append('g').attr('width', width);

    var xScale = d3.scale.linear()
      .domain([0, nodes.length])
      .range([0, height]);

    // Draw nodes
    nodes.forEach(function(d, i) {
      d.x = Math.round(xScale(i)) + 50;
      d.y = 300;
      d.cx = d.x + (i * 8);
      d.color = colors(i);
    });

    g.selectAll('.node')
      .data(nodes)
      .enter()
      .append('circle')
        .attr('fill', function(d, i) {
          return d.color;
        })
        .attr('id', function(d, i) { return d.nodeName; })
        .attr('cx', function(d, i) { return d.cx; })
        .attr('cy', function(d, i) { return d.y; })
        .attr('r', 4);

    g.selectAll('text')
      .data(nodes)
      .enter()
      .append('text')
        .text(function(d, i) {
          return d.nodeName;
        })
        .attr('class', 'writer')
        .attr('style', function(d, i) {
          return "fill: " + d.color + ";";
        })
        .attr('x', function(d, i) { return d.cx; })
        .attr('y', function(d, i) { 
          if (d.group === 1) {
            return d.y + 20;
          } else {
            return d.y - 20; 
          }
        })
        .attr('transform', function(d) {
          if (d.group === 1) {
            return 'rotate(90 ' + (d.cx) + ',' + (d.y + 20) + ')'
          } else {
            return 'rotate(-90 ' + (d.cx) + ',' + (d.y - 20) + ')'
          }
        })
      .on('click', function(d) {
        redraw(d);
      });

    // Draw arcs
    links.forEach(function(d, i) {
      d.x = (nodes[d.source].x - nodes[d.target].x) * 1.2, 
      d.y = nodes[d.source].y - nodes[d.target].y,
      d.r = Math.sqrt(d.x * d.x + d.y * d.y)
    });

    g.selectAll('path')
      .data(links)
      .enter()
      .append('path')
        .style('fill', 'transparent')
        .style('stroke', function(d, i) {
          return colors(i);
        })
        .attr('d', function(d) {
          return 'M ' + nodes[d.source].cx + ', ' + 100 + ' A ' + d.r + ' ' + d.r + ' 0 0 1' + nodes[d.target].cx + ', ' + 100;
        })
        .attr('transform', 'translate(0, 200)'); 
  };

  draw();



</script>

</body>
</html>